\documentclass[letterpaper,notitlepage,twoside]{article}

% Basic imports, increase margins...
\usepackage[margin=0.75in]{geometry}
\usepackage{amssymb}
\usepackage{amsmath}

% Finite State Machine stuff
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

% Format tables nicely
\usepackage[latin1]{inputenc}
\usepackage{array}
\usepackage{booktabs}
\setlength{\heavyrulewidth}{1.5pt}
\setlength{\abovetopsep}{4pt}

\usepackage{amsfonts} 
\usepackage{amssymb}
\usepackage{amsmath,amsthm}

\renewcommand{\implies}{\Rightarrow} % redefine command "implies"  
\renewcommand{\iff}{\Leftrightarrow} % double arrow
\newcommand{\maps}{\rightarrow} % define command "map" 
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\N}{\mathbb{N}} % natural number 
\newcommand{\Q}{\mathbb{Q}} % rational number 
\newcommand{\R}{\mathbb{R}} % real number 
\newcommand{\Z}{\mathbb{Z}} % integers 
\newcommand\tab[1][1cm]{\hspace*{#1}} %\tab command

% Add more packages that you use here...
\usepackage{braket}

\begin{document}
\title{Homework 30}
\author{Joe Baker, Brett Schreiber, Brian Knotten}
\maketitle

\section*{55}
Let $f \in BQP$ and let $M$ be a quantum turing machine that accepts $f$. Next construct a new quantum turing machine from $M$ called $M'$ which works the same as $M$ except it takes in a quantum register $m'$ of size $m+1$ where $M$ took in a quantum register of size $m$. Additionally the final qubit of the new register must be 0 if and only if all amplitudes of the first $m$ qubits correspond to the real-part of their amplitudes in the original $M$ and 1 if and only if all amplitudes of the first $m$ qubits correspond to the imaginary-part of their amplitudes in the original $M$. Then apply elementary quantum operations $F_1,...,F_T$ on $m'$. Finally measure the register and let $Y$ denote the obtained value.

\section*{57}
Let L be a language that has a PCP-verifier using $r$ coins and $q$ adaptive queries and let $V$ be the PCP-verifier with $q$ adaptive queries. We can construct a PCP-verifier $V'$ with $2^q$ non-adaptive queries by having $V'$ read all possible $2^q$ bits that can be read by $V$. $V$ will ask for the first address and get a single bit back, then ask for one of two second addresses based on whether or not the first bit was 0 or 1. This process continues for $q$ bits. $V$ can ask for at most $2^q$ locations. $V'$ will simply ask for all $2^q$ addresses all at once.
\section*{58}
Let $\pi^n$ be the proof string where the $i$th bit contains a polynomial $g(x)$ which is supposedly the permanent of the matrix encoded as $i$ with the 1st row and the $x$th column removed. The verifier composes $i$ as $A$ and queries for the $i$th bit of $\pi^n$. Then the verifier calculates $\Sigma_{c = 1}^{n - 1}a_cg(c)$ where $a_c$ is the $c$th value of the first row of $A$ and checks to make sure that the sum equals $k$. If it does not, reject. Then, do this for the second row of $A$ on the advice tape $\pi^{n - 1}$ and again compare the result to $k$. Continue this for all rows in $A$. \\\\
To deal with the multiple proof $\pi^1...\pi^n$, just concatenate all the proof strings into one, and have the verifier consider this offset in the query. The verifier does not use the result of each query in order to specify the next query, since the queries are determined only by the input.
\end{document}
