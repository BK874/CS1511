\documentclass[letterpaper,notitlepage,twoside]{article}

% Basic imports, increase margins...
\usepackage[margin=0.75in]{geometry}
\usepackage{amssymb}
\usepackage{amsmath}

% Finite State Machine stuff
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

% Format tables nicely
\usepackage[latin1]{inputenc}
\usepackage{array}
\usepackage{booktabs}
\setlength{\heavyrulewidth}{1.5pt}
\setlength{\abovetopsep}{4pt}

\usepackage{amsfonts} 
\usepackage{amssymb}
\usepackage{amsmath,amsthm}

\renewcommand{\implies}{\Rightarrow} % redefine command "implies"  
\renewcommand{\iff}{\Leftrightarrow} % double arrow
\newcommand{\maps}{\rightarrow} % define command "map" 
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\N}{\mathbb{N}} % natural number 
\newcommand{\Q}{\mathbb{Q}} % rational number 
\newcommand{\R}{\mathbb{R}} % real number 
\newcommand{\Z}{\mathbb{Z}} % integers 
\newcommand\tab[1][1cm]{\hspace*{#1}} %\tab command

% Add more packages that you use here...

\begin{document}
\title{Homework 25}
\author{Joe Baker, Brett Schreiber, Brian Knotten}
\maketitle

\section*{44}
\subsection*{a}
Given a one-way function $f$, it is possible to create a new one-way function $g$ which runs in $O(n^2)$ time as follows: \\
On input $x$ of size $n$: \\
\tab Split the input $x$ into $log(n)$ chunks: $x_1, x_2...x_{log(n)}$.
\tab for each $x_i$:
\tab \tab Compute $f(x_i)$, keeping track of the number of steps $f$ takes. After $n^2$ steps, just output $0$.
\tab Return $f(x_1) || f(x_2) ... || f(x_{log(n)}$ where $||$ is the concatenation of the bitstrings. Some of these substrings will be $0$.

First, $g$ runs in $O(n^2)$ time, because $f$ performing $log(n)$ computations. So $g$ is the complexity of $f$ multiplied by $log(n)$. Since we stop $f$ after $n^2$ steps, the total runtime is $n^2 * log(n) = O(n^2)$.

Second, $g$ is a one way function, since $g = f_U$, and $f_U$ is one-way as proved below.

\subsection*{b}
$f$ is one way $\implies f_U$ is one-way. This can be proved by contrapositive, that $f_U$ is not one-way $\implies f$ is not one way. \\
Assume $f_U$ is not one-way. Then there exists an algorithm $A_U$ which given $y$ can produce the $x$ such that $f_U(x') = y'$ in polynomial time. Then you can construct an algorithm $A$ which given $y$ can produce the $x$ such that $f(x) = y$ in polynomial time.

$A =$ on input $y$:
\begin{enumerate}
\item Generate $r = $ some number of random bits.
\item Construct the string $y' := y || r$.
\item Run $A$ on $y'$ to get $x'$.
\item If $f(x') = y$, return $x$, else, go back to step $1$.
\end{enumerate}

$A$ will halt in polynomial time because \\

\section*{45}


\end{document}
